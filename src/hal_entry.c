//视频:https://www.bilibili.com/video/BV14h4y1E7py
//作者：Hank(肖工)
#include "hal_data.h"
#include <stdio.h>
#include "smg.h"
#include "timer_smg.h"
#include "flash_smg.h"
#include "dht11.h"
#include "qe_touch_config.h"
FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

void qe_touch_sw(void);

//温湿度变量定义
uint8_t humdity_integer;//湿度整数
uint8_t humdity_decimal;//湿度小数
uint8_t temp_integer ;//温度整数
uint8_t temp_decimal ;//温度小数
uint8_t dht11_check ;//校验值

//数码管变量
uint8_t num1=0,num2=0,num3=0,num4=0;//4个数码管显示的数值
uint16_t year=2023,month=7,day=26,week=3;//年月日周
uint8_t num_flag=0;//4个数码管和冒号轮流显示，一轮刷新五次
int alarm_hour,alarm_min,alarm_count=1;//闹铃


//RTC变量
/* rtc_time_t is an alias for the C Standard time.h struct 'tm' */
rtc_time_t set_time =
{
    .tm_sec  = 50,      /* 秒，范围从 0 到 59 */
    .tm_min  = 59,      /* 分，范围从 0 到 59 */
    .tm_hour = 23,      /* 小时，范围从 0 到 23*/
    .tm_mday = 26,       /* 一月中的第几天，范围从 0 到 30*/
    .tm_mon  = 7,      /* 月份，范围从 0 到 11*/
    .tm_year = 123,     /* 自 1900 起的年数，2023为123*/
    .tm_wday = 3,       /* 一周中的第几天，范围从 0 到 6*/
//    .tm_yday=0,         /* 一年中的第几天，范围从 0 到 365*/
//    .tm_isdst=0;        /* 夏令时*/
};


//RTC闹钟变量
rtc_alarm_time_t set_alarm_time=
{
     .time.tm_sec  = 58,      /* 秒，范围从 0 到 59 */
     .time.tm_min  = 59,      /* 分，范围从 0 到 59 */
     .time.tm_hour = 23,      /* 小时，范围从 0 到 23*/
     .time.tm_mday = 26,       /* 一月中的第几天，范围从 1 到 31*/
     .time.tm_mon  = 7,      /* 月份，范围从 0 到 11*/
     .time.tm_year = 123,     /* 自 1900 起的年数，2023为123*/
     .time.tm_wday = 6,       /* 一周中的第几天，范围从 0 到 6*/

     .sec_match        =  0,//每次秒到达设置的进行报警
     .min_match        =  1,
     .hour_match       =  1,
     .mday_match       =  0,
     .mon_match        =  0,
     .year_match       =  0,
     .dayofweek_match  =  0,
    };

bsp_io_level_t sw1;//按键SW1状态
bsp_io_level_t sw2;//按键SW2状态
bsp_io_level_t sw3;//按键SW3状态
bsp_io_level_t sw4;//按键SW4状态
bsp_io_level_t qe_sw;//触摸电容状态

int sw1_num1=0;//按键SW1计数值，去抖和长按短按判断
int sw2_num1=0;//按键SW2计数值，去抖和长按短按判断
int sw3_num1=0;//按键SW3计数值，去抖和长按短按判断
int sw4_num1=0;//按键SW4计数值，去抖和长按短按判断
int qe_sw_num1=0;//触摸按键计数值，去抖和长按短按判断
void qe_touch_sw(void);

//数码管显示状态，0正常显示，1修改小时，2修改分钟，3保存时间修改数据，4温度，5湿度，6显示日期，7修改年，8修改月，9修改日，10修改周
//11保存日期,12倒计时，13倒计时分钟，14倒计时秒,15闹铃时间，16修改闹铃时，17修改闹铃分
int smg_mode=0;
int sec=0,min=0,hour=0;//保存时间数据
uint16_t t_year=0,t_month=0,t_day=0,t_week=0;//保存年月日周
uint16_t time_mode_num=0;//定时器刷新时间，实现闪烁效果

int rtc_adjust_sec=1;//每60S减1S
int rtc_adjust_min=1;//每10min减1S
int flag_adjust=0;//调秒标志位

volatile uint8_t g_src_uint8[6]={0x00,0x00,0x00,0x00,0x00,0x00};//时间保存在该数组里面
volatile uint8_t  g_src_uint8_length=6;
uint8_t flash_flag=0;//保存时间数据，一半在每过一分钟或者按键修改时间


//RTC回调函数
volatile bool rtc_flag = 0;//RTC延时1s标志位
volatile bool rtc_alarm_flag = 0;//RTC闹钟
/* Callback function */
void rtc_callback(rtc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == RTC_EVENT_PERIODIC_IRQ)
        rtc_flag=1;
    else if(p_args->event == RTC_EVENT_ALARM_IRQ)
        rtc_alarm_flag=1;
}


fsp_err_t err = FSP_SUCCESS;
volatile bool uart_send_complete_flag = false;
void user_uart_callback (uart_callback_args_t * p_args)
{
    if(p_args->event == UART_EVENT_TX_COMPLETE)
    {
        uart_send_complete_flag = true;
    }
}

#ifdef __GNUC__                                 //串口重定向
    #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
    #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif

PUTCHAR_PROTOTYPE
{
        err = R_SCI_UART_Write(&g_uart9_ctrl, (uint8_t *)&ch, 1);
        if(FSP_SUCCESS != err) __BKPT();
        while(uart_send_complete_flag == false){}
        uart_send_complete_flag = false;
        return ch;
}

int _write(int fd,char *pBuffer,int size)
{
    for(int i=0;i<size;i++)
    {
        __io_putchar(*pBuffer++);
    }
    return size;
}





/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
/**********************DHT11初始化***************************************/
       R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_03_PIN_01, BSP_IO_LEVEL_HIGH);
       R_BSP_SoftwareDelay(1000U, BSP_DELAY_UNITS_MILLISECONDS);

    /* Open the transfer instance with initial configuration. */
       err = R_SCI_UART_Open(&g_uart9_ctrl, &g_uart9_cfg);
       assert(FSP_SUCCESS == err);
/**********************数码管测试***************************************/
//              ceshi_smg();
/**********************定时器开启***************************************/
    /* Initializes the module. */
    err = R_GPT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    assert(FSP_SUCCESS == err);
    /* Start the timer. */
    (void) R_GPT_Start(&g_timer0_ctrl);

/**********************data flash***************************************/
    flash_result_t blank_check_result;
    /* Open the flash lp instance. */
    err = R_FLASH_LP_Open(&g_flash0_ctrl, &g_flash0_cfg);
    assert(FSP_SUCCESS == err);

    //       WriteFlashTest(4,g_src_uint8 ,FLASH_DF_BLOCK_0);

    PrintFlashTest(FLASH_DF_BLOCK_0);

    set_time.tm_sec=0;//时间数据 秒
    set_time.tm_min=min;//时间数据 分钟
    set_time.tm_hour=hour;//时间数据 小时
    set_time.tm_mday=day;//时间数据 日
    set_time.tm_mon=month;//时间数据 月
    set_time.tm_year=year-1900;//时间数据 年
    set_time.tm_wday=week;//时间数据 周

/**********************RTC开启***************************************/
    /* Initialize the RTC module*/
    err = R_RTC_Open(&g_rtc0_ctrl, &g_rtc0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    assert(FSP_SUCCESS == err);

    /* Set the RTC clock source. Can be skipped if "Set Source Clock in Open" property is enabled. */
    R_RTC_ClockSourceSet(&g_rtc0_ctrl);

    /* R_RTC_CalendarTimeSet must be called at least once to start the RTC */
    R_RTC_CalendarTimeSet(&g_rtc0_ctrl, &set_time);
    /* Set the periodic interrupt rate to 1 second */
    R_RTC_PeriodicIrqRateSet(&g_rtc0_ctrl, RTC_PERIODIC_IRQ_SELECT_1_SECOND);

    R_RTC_CalendarAlarmSet(&g_rtc0_ctrl, &set_alarm_time);
    uint8_t rtc_second= 0;      //秒
    uint8_t rtc_minute =0;      //分
    uint8_t rtc_hour =0;         //时
    uint8_t rtc_day =0;          //日
    uint8_t rtc_month =0;      //月
    uint16_t rtc_year =0;        //年
    uint8_t rtc_week =0;        //周
    rtc_time_t get_time;

    sec=set_time.tm_sec;//时间数据 秒
    min=set_time.tm_min;//时间数据 分钟
    hour=set_time.tm_hour;//时间数据 小时
    day=set_time.tm_mday;//时间数据 日
    month=set_time.tm_mon;//时间数据 月
    year=set_time.tm_year+1900;//时间数据 年
    week=set_time.tm_wday;//时间数据 周
    alarm_hour=set_alarm_time.time.tm_hour;//闹铃数据 小时
    alarm_min=set_alarm_time.time.tm_min;//闹铃数据 分钟

    /* Open Touch middleware */
    err = RM_TOUCH_Open(g_qe_touch_instance_config01.p_ctrl, g_qe_touch_instance_config01.p_cfg);
    if (FSP_SUCCESS != err)
    {
       while (true) {}
    }


    while(1)
    {
       if(flash_flag)//按键修改完毕数据后进行保存
       {
           g_src_uint8[0]=hour;
           g_src_uint8[1]=min;
           g_src_uint8[2]=year-1900;
           g_src_uint8[3]=month;
           g_src_uint8[4]=day;
           g_src_uint8[5]=week;
           WriteFlashTest(6,g_src_uint8 ,FLASH_DF_BLOCK_0);
           flash_flag=0;
       }


       if(rtc_flag)
       {
           R_RTC_CalendarTimeGet(&g_rtc0_ctrl, &get_time);//获取RTC计数时间
           rtc_flag=0;
           rtc_second=get_time.tm_sec;//秒
           rtc_minute=get_time.tm_min;//分
           rtc_hour=get_time.tm_hour;//时
           rtc_day=get_time.tm_mday;//日
           rtc_month=get_time.tm_mon;//月
           rtc_year=get_time.tm_year; //年
           rtc_week=get_time.tm_wday;//周

           if(rtc_adjust_sec==60)//每60S调整一次
           {
               flag_adjust++;
               rtc_adjust_sec=1;
//               if(get_time.tm_sec==0)//如果刚好是0S则下一秒调整
//               {
//                   rtc_adjust_sec=59;
//               }
//               else
//               {
//                   set_time.tm_sec=get_time.tm_sec-1;
//                   set_time.tm_min=get_time.tm_min;
//                   set_time.tm_hour=get_time.tm_hour ;
//                   set_time.tm_mday=get_time.tm_mday;
//                   set_time.tm_mon=get_time.tm_mon;
//                   set_time.tm_year=get_time.tm_year;
//                   set_time.tm_wday=get_time.tm_wday;
//                   R_RTC_CalendarTimeSet(&g_rtc0_ctrl, &set_time);
//                   rtc_adjust_sec=0;
//               }
               if(rtc_adjust_min==10)//每10min调整一次
               {
                   flag_adjust++;
                   rtc_adjust_min=1;
               }
               else
               {
                   rtc_adjust_min++;
               }
           }
           else
               rtc_adjust_sec++;

           if(flag_adjust)
           {
               if(get_time.tm_sec==0){;}
               else
               {
                   set_time.tm_sec=get_time.tm_sec-1;
                   set_time.tm_min=get_time.tm_min;
                   set_time.tm_hour=get_time.tm_hour ;
                   set_time.tm_mday=get_time.tm_mday;
                   set_time.tm_mon=get_time.tm_mon;
                   set_time.tm_year=get_time.tm_year;
                   set_time.tm_wday=get_time.tm_wday;
                   R_RTC_CalendarTimeSet(&g_rtc0_ctrl, &set_time);
                   flag_adjust--;
               }
           }

           printf(" %d y %d m %d d %d h %d m %d s %d w\n",rtc_year+1900,rtc_month,rtc_day,rtc_hour,rtc_minute,rtc_second,rtc_week);
//           printf("hour_match--%d min_match--%d rtc_alarm_flag--%d\n",set_alarm_time.hour_match,set_alarm_time.min_match,rtc_alarm_flag);
//           printf("alarmhour--%d alarmmin--%d\n",set_alarm_time.time.tm_hour,set_alarm_time.time.tm_min);

            //时间显示
           num1=rtc_hour/10;
           num2=rtc_hour%10;
           num3=rtc_minute/10;
           num4=rtc_minute%10;
           t_year=rtc_year+1900;
           t_month=rtc_month;
           t_day=rtc_day;
           t_week=rtc_week;
           if(rtc_second==0&&smg_mode==0)//这个时候刷新变量
           {
               sec=rtc_second;//时间数据 秒
               min=rtc_minute;//时间数据 分钟
               hour=rtc_hour;//时间数据 小时
               day=rtc_day;//时间数据 日
               month=rtc_month;//时间数据 月
               year=rtc_year+1900;//时间数据 年
               week=rtc_week;//时间数据 周

               g_src_uint8[0]=hour;
               g_src_uint8[1]=min;
               g_src_uint8[2]=year;
               g_src_uint8[3]=month;
               g_src_uint8[4]=day;
               g_src_uint8[5]=week;
               WriteFlashTest(6,g_src_uint8 ,FLASH_DF_BLOCK_0);


           }
           if(rtc_second%5==0)//5S读一次
           {
               DHT11_Read();
               printf("hum=%d temp=%d\n",humdity_integer,temp_integer);

           }

       }
       if(rtc_alarm_flag)
       {
           if(alarm_count<50)
           {
               if(alarm_count==1)
               {
                   BeepInitial();
                   printf("/************************Alarm Clock********************************/\n");
               }
               else
                   BeepOpen();
           }
           else
               BeepStop();
           alarm_count++;
           if(alarm_count>100)
               alarm_count=0;
//           rtc_alarm_flag=0;
       }
       qe_touch_sw();
       set_smg_button();
       R_BSP_SoftwareDelay(10U, BSP_DELAY_UNITS_MILLISECONDS);
    }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}


void qe_touch_sw(void)
{
    /* for [CONFIG01] configuration */
    err = RM_TOUCH_ScanStart(g_qe_touch_instance_config01.p_ctrl);
    if (FSP_SUCCESS != err)
    {
        while (true) {}
    }
    while (0 == g_qe_touch_flag) {}
    g_qe_touch_flag = 0;
    uint64_t button_status;
    err = RM_TOUCH_DataGet(g_qe_touch_instance_config01.p_ctrl, &button_status, NULL, NULL);
    if (FSP_SUCCESS == err)
    {
        /* TODO: Add your own code here. */
        if(button_status & (0b1 ) )
            qe_sw=1;
        else
            qe_sw=0;
    }

}




/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
